#include "FullScreenStructs.hlsli"
	// Circular DOF by Kleber Garcia "Kecho" - 2017
// Click mouse in image and move to test circle dof size.
// Big circles can get achieved in linear time.
// Publication & Filter generator: https://github.com/kecho/CircularDofFilterGenerator
// yehar's blog: http://yehar.com/blog/?p=1495

// Test knobs:
#define ANIMATE_FILTER_SIZE
#define SLIDE_SHOW
//filter size can be bigger than 1, but then undersampling will occur.
#define MAX_FILTER_SIZE 1.0


// Prenormalization step available in siggraph publication. Can be generated by an offline tool, or passed as a cbuffer.
// Small slideshow to show effect on multiple images.

//Filter values:
/********************************************************************/
/********************************************************************/
/*         Generated Filter by CircularDofFilterGenerator tool      */
/*     Copyright (c)     Kleber A Garcia  (kecho_garcia@hotmail.com)*/
/*           https://github.com/kecho/CircularDofFilterGenerator    */
/********************************************************************/
/********************************************************************/
/**
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
**/
#define KERNEL_RADIUS  8
#define KERNEL_COUNT 17
// const float4 Kernel0BracketsRealXY_ImZW = float4(-0.038708,0.943062,-0.025574,0.660892);
// const float2 Kernel0Weights_RealX_ImY = float2(0.411259,-0.548794);

// const float4 Kernel1BracketsRealXY_ImZW = float4(0.000115,0.559524,0.000000,0.178226);
// const float2 Kernel1Weights_RealX_ImY = float2(0.513282,4.561110);

//(Pr+Pi)*(Qr+Qi) = (Pr*Qr+Pr*Qi+Pi*Qr-Pi*Qi)
float2 multComplex(float2 p, float2 q)
{
    return float2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);
}

float4 getFilters(int x)
{
    return blur_filterConstants.Load(int3(x, 0, 0));
}
Texture2DArray imageBands : register(t8);
Texture2D<float4> fullscreenTextureMask	: register(t11);
PixelOutput main(VertexToPixel input)
{

    float2 Kernel0Weights_RealX_ImY = float2(0.411259,-0.548794);
    float2 Kernel1Weights_RealX_ImY = float2(0.513282,4.561110);

	PixelOutput output;
	float2 uv = input.myUV.xy;
    float2 stepVal = 1.0/ (float2(frameRenderResolutionX, frameRenderResolutionY) * 0.5f);
  
    float4 valR = float4(0,0,0,0);
    float4 valG = float4(0,0,0,0);
    float4 valB = float4(0,0,0,0);
    float filterRadius = fullscreenTextureMask.Sample(defaultSampler, input.myUV).w;
    float4 sampleTexelR = imageBands.Sample(defaultSampler,  float3(input.myUV, 0.f));
    float4 sampleTexelG = imageBands.Sample(defaultSampler,  float3(input.myUV, 1.f));
    float4 sampleTexelB = imageBands.Sample(defaultSampler,  float3(input.myUV, 2.f));
    for (int i = 0; i < KERNEL_COUNT; i++)
    {
        float2 coords = uv + stepVal*float2(0.0,float(i  - KERNEL_RADIUS))*filterRadius;
        float4 imageTexelR = imageBands.Sample(defaultSampler,  float3(coords, 0.f));  
        float4 imageTexelG = imageBands.Sample(defaultSampler,  float3(coords, 1.f));  
        float4 imageTexelB = imageBands.Sample(defaultSampler,  float3(coords, 2.f));  
        float mask = fullscreenTextureMask.Sample(defaultSampler, coords).w;
        imageTexelR = lerp(sampleTexelR, imageTexelR, smoothstep(0, 0.75f, mask));
        imageTexelG = lerp(sampleTexelG, imageTexelG, smoothstep(0, 0.75f, mask));
        imageTexelB = lerp(sampleTexelB, imageTexelB, smoothstep(0, 0.75f, mask));
        // if(mask < 0.15f)
        // {
        //     imageTexelR = sampleTexelR;
        //     imageTexelG = sampleTexelG;
        //     imageTexelB = sampleTexelB;
        // }
        float4 c0_c1 = getFilters(i);
        
        
        valR.xy += multComplex(imageTexelR.xy,c0_c1.xy);
        valR.zw += multComplex(imageTexelR.zw,c0_c1.zw);
        
        valG.xy += multComplex(imageTexelG.xy,c0_c1.xy);
        valG.zw += multComplex(imageTexelG.zw,c0_c1.zw);
        
        valB.xy += multComplex(imageTexelB.xy,c0_c1.xy);
        valB.zw += multComplex(imageTexelB.zw,c0_c1.zw);       
    }
    
    float redChannel   = dot(valR.xy,Kernel0Weights_RealX_ImY)+dot(valR.zw,Kernel1Weights_RealX_ImY);
    float greenChannel = dot(valG.xy,Kernel0Weights_RealX_ImY)+dot(valG.zw,Kernel1Weights_RealX_ImY);
    float blueChannel  = dot(valB.xy,Kernel0Weights_RealX_ImY)+dot(valB.zw,Kernel1Weights_RealX_ImY);
    output.myColor = float4(sqrt(float3(redChannel,greenChannel,blueChannel)), 1.0);   	
	//output.myColor = float4((float3(redChannel,greenChannel,blueChannel)), 1.0); 
	return output;
}